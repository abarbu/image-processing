(module image-processing *
(import chicken scheme extras)
(use traversal define-structure scheme2c-compatibility linear-algebra format miscmacros)

;;; Images

(define *max-red* 255)
(define *max-green* 255)
(define *max-blue* 255)
(define *max-grey* 255)
(define *max-hue* 360)
(define *max-saturation* 100)
(define *max-value* 100)

(define (rgb->hsv rgb)
 ;; The constants are hardwired to be inexact for efficiency.
 (let* ((red (/ (vector-ref rgb 0) *max-red*))
	(green (/ (vector-ref rgb 1) *max-green*))
	(blue (/ (vector-ref rgb 2) *max-blue*))
	(value (max red green blue))
	(m (min red green blue))
	(saturation (if (zero? value) 0.0 (/ (- value m) value)))
	(hue (if (zero? saturation)
		 0.0
		 (/ (let ((rc (/ (- value red) (- value m)))
			  (gc (/ (- value green) (- value m)))
			  (bc (/ (- value blue) (- value m))))
		     (cond ((= red value) (- bc gc))
			   ((= green value) (+ 2.0 (- rc bc)))
			   (else (+ 4.0 (- gc rc)))))
		    6.0)))
	(hue (if (negative? hue) (+ hue 1.0) hue)))
  (vector (inexact->exact (floor (* *max-hue* hue)))
	  (inexact->exact (floor (* *max-saturation* saturation)))
	  (inexact->exact (floor (* *max-value* value))))))

(define (hsv->rgb hsv)
 ;; The constants are hardwired to be inexact for efficiency.
 (let ((hue (/ (vector-ref hsv 0) *max-hue*))
       (saturation (/ (vector-ref hsv 1) *max-saturation*))
       (value (* (max *max-red* *max-green* *max-blue*)
		 (/ (vector-ref hsv 2) *max-value*))))
  (if (zero? saturation)
      (vector (inexact->exact (floor value))
	      (inexact->exact (floor value))
	      (inexact->exact (floor value)))
      (let* ((hue (if (negative? hue) (+ hue 1.0) hue))
	     (hue (* 6.0 hue))
	     (fract (- hue (floor hue)))
	     (new1 (inexact->exact (floor (* value (- 1.0 saturation)))))
	     (new2 (inexact->exact
		    (floor (* value (- 1.0 (* saturation fract))))))
	     (new3 (inexact->exact
		    (floor (* value (- 1.0 (* saturation (- 1.0 fract)))))))
	     (value (inexact->exact (floor value))))
       (case (inexact->exact (floor hue))
	((0) (vector value new3 new1))
	((1) (vector new2 value new1))
	((2) (vector new1 value new3))
	((3) (vector new1 new2 value))
	((4) (vector new3 new1 value))
	((5) (vector value new1 new2))
	((6) (vector value new3 new1))
	(else (error "Inappropriate hue angle")))))))

(define (rgb->cd rgb)
 (let* ((red (vector-ref rgb 0))
	(green (vector-ref rgb 1))
	(blue (vector-ref rgb 2))
	(intensity (max (+ red green blue) 1)))
  (vector (inexact->exact (floor (* *max-red* (/ red intensity))))
	  (inexact->exact (floor (* *max-green* (/ green intensity)))))))

(define (##image-processing#exact-round f) (inexact->exact (round f)))

(define (rgb->cmyk rgb)
 (let* ((r (vector-ref rgb 0))
	(g (vector-ref rgb 1))
	(b (vector-ref rgb 2))
	(k (max r g b)))
  (if (zero? k)
      '#(0 0 0 0)
      `#(,(##image-processing#exact-round (* 255 (- 1 (/ r k))))
	 ,(##image-processing#exact-round (* 255 (- 1 (/ g k))))
	 ,(##image-processing#exact-round (* 255 (- 1 (/ b k))))
	 ,k))))

(define (rgb->uv-hsv c)
 (let ((hsv (rgb->hsv c)))
  `#(,(##image-processing#exact-round (+ (- (* 0.169 (x c))) (* 0.331 (y c)) (* 0.5 (z c))))
     ,(##image-processing#exact-round (+ (* 0.5 (x c)) (- (* 0.418 (y c))) (- (* 0.082 (z c)))))
     ,(x hsv) ,(y hsv) ,(z hsv))))

(define-structure pbm raw? bitmap)
(define-structure pgm raw? maxval grey)
(define-structure ppm raw? maxval red green blue)

(define (pnm? m) (or (pbm? m) (pgm? m) (ppm? m)))

(define (image-ref i p)
 (cond ((pbm? i) (matrix-ref (pbm-bitmap i) (y p) (x p)))
       ((pgm? i) (matrix-ref (pgm-grey i) (y p) (x p)))
       ((ppm? i)
	`#(,(matrix-ref (ppm-red i) (y p) (x p))
	   ,(matrix-ref (ppm-blue i) (y p) (x p))
	   ,(matrix-ref (ppm-green i) (y p) (x p))))
       ((matrix? i) (matrix-ref i (y p) (x p)))
       (else (fuck-up))))

(define (pnm-width pnm)
 (matrix-columns (cond ((pbm? pnm) (pbm-bitmap pnm))
		       ((pgm? pnm) (pgm-grey pnm))
		       ((ppm? pnm) (ppm-red pnm))
		       (else (error "Argument not PNM")))))

(define (pnm-height pnm)
 (matrix-rows (cond ((pbm? pnm) (pbm-bitmap pnm))
		    ((pgm? pnm) (pgm-grey pnm))
		    ((ppm? pnm) (ppm-red pnm))
		    (else (error "Argument not PNM")))))

(define (read-pnm pathname)
 (define (read-pnm port)
  (define (read-pbm raw?)
   (let* ((width (read port))
	  (height (read port))
	  (bitmap (make-matrix height width 0)))
    (call-with-current-continuation
     (lambda (return)
      (cond
       (raw? (error "Cannot (yet) read a raw pbm image"))
       (else
	(for-each-n (lambda (y)
		     (for-each-n (lambda (x)
				  (let ((v (read port)))
				   (when (eof-object? v) (return #f))
				   ;; Yes, it really is the case (at least
				   ;; according to xv) that 0 means white and
				   ;; 1 means black for ascii pbm images.
				   (matrix-set! bitmap y x (zero? v))))
                      width))
         height)))))
    (make-pbm raw? bitmap)))
  (define (read-pgm raw?)
   (let* ((width (read port))
	  (height (read port))
	  (maxval (read port))
	  (size (* width height))
	  (grey (make-matrix height width 0)))
    (call-with-current-continuation
     (lambda (return)
      (cond
       (raw?
	(read-char port)
	(for-each-n
          (lambda (y)
           (for-each-n (lambda (x)
                        (let ((c (read-char port)))
                         (when (eof-object? c) (return #f))
                         (let ((int (if (< 255 maxval)
                                        (+ (bit-lsh (char->integer c) 8)
                                           (char->integer (read-char port)))
                                        (char->integer c))))
                          (matrix-set! grey y x int))))
            width))
	 height))
       (else (for-each-n (lambda (y)
			  (for-each-n (lambda (x)
				       (let ((v (read port)))
					(when (eof-object? v) (return #f))
					(matrix-set! grey y x v)))
                           width))
              height)))))
    (make-pgm raw? maxval grey)))
  (define (read-ppm raw?)
   (let* ((width (read port))
	  (height (read port))
	  (maxval (read port))
	  (size (* width height))
	  (red (make-matrix height width 0))
	  (green (make-matrix height width 0))
	  (blue (make-matrix height width 0)))
    (call-with-current-continuation
     (lambda (return)
      (cond (raw? (read-char port)
		  (for-each-n
                    (lambda (y)
                     (for-each-n
                       (lambda (x)
                        (let* ((c1 (read-char port))
                               (c2 (read-char port))
                               (c3 (read-char port)))
                         (when (eof-object? c1) (return #f))
                         (matrix-set! red y x (char->integer c1))
                         (matrix-set! green y x (char->integer c2))
                         (matrix-set! blue y x (char->integer c3))))
                      width))
		   height))
	    (else (for-each-n
                    (lambda (y)
                     (for-each-n (lambda (x)
                                  (let* ((v1 (read port))
                                         (v2 (read port))
                                         (v3 (read port)))
                                   (when (eof-object? v1) (return #f))
                                   (matrix-set! red y x v1)
                                   (matrix-set! green y x v2)
                                   (matrix-set! blue y x v3)))
                      width))
		   height)))))
    (make-ppm raw? maxval red green blue)))
  (let ((format (read port)))
   (read-char port)
   (while (char=? (peek-char port) #\#) (read-line port))
   (case format
    ((p1) (read-pbm #f))
    ((p2) (read-pgm #f))
    ((p3) (read-ppm #f))
    ((p4) (read-pbm #t))
    ((p5) (read-pgm #t))
    ((p6) (read-ppm #t))
    (else (error "Incorrect format for a pnm image")))))
 (cond ((port? pathname) (read-pnm pathname))
       ((string=? pathname "-") (read-pnm (current-input-port)))
       (else (call-with-input-file pathname read-pnm))))

(define (write-pnm pnm pathname)
 (define (write-pnm port)
  (define (write-pbm pbm)
   (let ((width (pnm-width pbm))
	 (height (pnm-height pbm))
	 (bitmap (pbm-bitmap pbm)))
    (write (if (pbm-raw? pbm) 'p4 'p1) port)
    (newline port)
    (write width port)
    (write-char #\space port)
    (write height port)
    (newline port)
    (if (pbm-raw? pbm)
	(error "Cannot (yet) write a raw pbm image")
	(for-each-n (lambda (y)
		     (for-each-n (lambda (x)
				  ;; Yes, it really is the case (at least
				  ;; according to xv) that 0 means white and
				  ;; 1 means black for ascii pbm images.
				  (write (if (matrix-ref bitmap y x) 0 1) port)
				  (newline port))
                      width))
         height))))
  (define (write-pgm pgm)
   (let ((width (pnm-width pgm))
	 (height (pnm-height pgm))
	 (grey (pgm-grey pgm)))
    (when (pgm-raw? pgm)
     (for-each-n
       (lambda (y)
        (for-each-n (lambda (x)
                     (when (> (matrix-ref grey y x) 255)
                      (error "Grey value too large for raw pgm file format")))
         width))
      height))
    (write (if (pgm-raw? pgm) 'p5 'p2) port)
    (newline port)
    (write width port)
    (write-char #\space port)
    (write height port)
    (newline port)
    (write (pgm-maxval pgm) port)
    (newline port)
    (if (pgm-raw? pgm)
	(for-each-n
          (lambda (y)
           (for-each-n
             (lambda (x) (write-char (integer->char (matrix-ref grey y x)) port))
            width))
	 height)
	(for-each-n (lambda (y)
		     (for-each-n (lambda (x)
				  (write (matrix-ref grey y x) port)
				  (newline port))
                      width))
         height))))
  (define (write-ppm ppm)
   (let ((width (pnm-width ppm))
	 (height (pnm-height ppm))
	 (red (ppm-red ppm))
	 (green (ppm-green ppm))
	 (blue (ppm-blue ppm)))
    (when (ppm-raw? ppm)
     (for-each-n
       (lambda (y)
        (for-each-n (lambda (x)
                     (when (or (> (matrix-ref red y x) 255)
			      (> (matrix-ref green y x) 255)
			      (> (matrix-ref blue y x) 255))
                      (error "Color value too large for raw ppm file format")))
         width))
      height))
    (write (if (ppm-raw? ppm) 'p6 'p3) port)
    (newline port)
    (write width port)
    (write-char #\space port)
    (write height port)
    (newline port)
    (write (ppm-maxval ppm) port)
    (newline port)
    (if (ppm-raw? ppm)
	(for-each-n
          (lambda (y)
           (for-each-n (lambda (x)
                        (write-char (integer->char (matrix-ref red y x)) port)
                        (write-char (integer->char (matrix-ref green y x)) port)
                        (write-char (integer->char (matrix-ref blue y x)) port))
            width))
	 height)
	(for-each-n (lambda (y)
		     (for-each-n (lambda (x)
				  (write (matrix-ref red y x) port)
				  (newline port)
				  (write (matrix-ref green y x) port)
				  (newline port)
				  (write (matrix-ref blue y x) port)
				  (newline port))
                      width))
         height))))
  (cond ((pbm? pnm) (write-pbm pnm))
	((pgm? pnm) (write-pgm pnm))
	((ppm? pnm) (write-ppm pnm))
	(else (error "Non-PNM argument to WRITE-PNM"))))
 (cond ((port? pathname) (write-pnm pathname))
       ((string=? pathname "-") (write-pnm (current-output-port)))
       (else (call-with-output-file (default-extension
                                     pathname
                                     (cond ((pbm? pnm) "pbm")
                                           ((pgm? pnm) "pgm")
                                           ((ppm? pnm) "ppm")
                                           (else (fuck-up))))
              write-pnm))))

(define (pnm-movie-frame-pathname pathname i)
 (when (string=? pathname "-") (error "Invalid pathname"))
 (let ((i (+ i 1)))
  (replace-extension (string-append (strip-extension pathname)
				    "_"
				    (cond ((< i 10) "0000")
					  ((< i 100) "000")
					  ((< i 1000) "00")
					  ((< i 10000) "0")
					  (else ""))
				    (number->string i))
		     (extension pathname))))

(define (pnm-movie-length pathname)
 (let loop ((i 0))
  (if (file-exists? (pnm-movie-frame-pathname pathname i))
      (loop (+ i 1))
      i)))

(define (read-pnm-movie pathname)
 (list->vector
  (map-n (lambda (i) (read-pnm (pnm-movie-frame-pathname pathname i)))
   (pnm-movie-length pathname))))

(define (write-pnm-movie pnm-movie pathname)
 (for-each-indexed
  (lambda (pnm i) (write-pnm pnm (pnm-movie-frame-pathname pathname i)))
  (vector->list pnm-movie)))

(define (read-mpeg pathname)
 ;; needs work: To create unique temporary pathnames to avoid clashes between
 ;;             multiple processes.
 (when (string=? pathname "-") (error "Invalid pathname"))
 (system (format #f "rm -f ~a ~a"
		 (tmp "QobiScheme.mpg")
		 (tmp "QobiScheme_?????.ppm")))
 (system (format #f "cp ~a ~a"
		 (default-extension pathname "Mpeg1")
		 (tmp "QobiScheme.mpg")))
 (system
  (format #f "(cd ~a;mpeg_play -quality on -dither ppm -quiet QobiScheme.mpg)"
	  *tmp*))
 (let ((pnm-movie (read-pnm-movie (tmp "QobiScheme.ppm"))))
  (system (format #f "rm -f ~a ~a"
		  (tmp "QobiScheme.mpg")
		  (tmp "QobiScheme_?????.ppm")))
  pnm-movie))

(define (write-mpeg pnm-movie pathname)
 ;; needs work: To create unique temporary pathnames to avoid clashes between
 ;;             multiple processes.
 (when (string=? pathname "-") (error "Invalid pathname"))
 (system (format #f "rm -f ~a ~a"
		 (tmp "QobiScheme.param")
		 (tmp "QobiScheme_?????.pnm")))
 (call-with-output-file (tmp "QobiScheme.param")
  (lambda (port)
   (format port "PATTERN          IBBPBBPBBPBBPBBP~%")
   (format port "OUTPUT           ~a~%" (default-extension pathname "Mpeg1"))
   (format port "BASE_FILE_FORMAT PNM~%")
   (format port "INPUT_CONVERT    *~%")
   (format port "GOP_SIZE         16~%")
   (format port "SLICES_PER_FRAME 1~%")
   (format port "INPUT_DIR        ~a~%" *tmp*)
   (format port "INPUT~%")
   (format port "QobiScheme_*.pnm [00001-~a~s]~%"
	   (let ((n (vector-length pnm-movie)))
	    (cond ((< n 10) "0000")
		  ((< n 100) "000")
		  ((< n 1000) "00")
		  ((< n 10000) "0")
		  (else "")))
	   (vector-length pnm-movie))
   (format port "END_INPUT~%")
   (format port "PIXEL            HALF~%")
   (format port "RANGE            10~%")
   (format port "PSEARCH_ALG      LOGARITHMIC~%")
   (format port "BSEARCH_ALG      CROSS2~%")
   (format port "IQSCALE          8~%")
   (format port "PQSCALE          10~%")
   (format port "BQSCALE          25~%")
   (format port "REFERENCE_FRAME  ORIGINAL~%")
   (format port "BIT_RATE         1000000~%")
   (format port "BUFFER_SIZE      327680~%")
   (format port "FRAME_RATE       30~%")
   (format port "FORCE_ENCODE_LAST_FRAME~%")))
 (write-pnm-movie pnm-movie (tmp "QobiScheme.pnm"))
 (system (format #f "mpeg_encode ~a >/dev/null" (tmp "QobiScheme.param")))
 (system (format #f "rm -f ~a ~a"
		 (tmp "QobiScheme.param")
		 (tmp "QobiScheme_?????.pnm"))))

(define (clip-mpeg input-pathname output-pathname first-frame last-frame)
 ;; needs work: To create unique temporary pathnames to avoid clashes between
 ;;             multiple processes.
 (when (or (string=? input-pathname "-") (string=? output-pathname "-"))
  (error "Invalid pathname"))
 (system (format #f "rm -f ~a ~a"
		 (tmp "QobiScheme.{mpg,param}")
		 (tmp "QobiScheme_?????.ppm")))
 (system (format #f "cp ~a ~a"
		 (default-extension input-pathname "Mpeg1")
		 (tmp "QobiScheme.mpg")))
 (system
  (format #f "(cd ~a;mpeg_play -quality on -dither ppm -quiet QobiScheme.mpg)"
	  *tmp*))
 (call-with-output-file (tmp "QobiScheme.param")
  (lambda (port)
   (format port "PATTERN          IBBPBBPBBPBBPBBP~%")
   (format port "OUTPUT           ~a~%"
	   (default-extension output-pathname "Mpeg1"))
   (format port "BASE_FILE_FORMAT PNM~%")
   (format port "INPUT_CONVERT    *~%")
   (format port "GOP_SIZE         16~%")
   (format port "SLICES_PER_FRAME 1~%")
   (format port "INPUT_DIR        ~a~%" *tmp*)
   (format port "INPUT~%")
   (format port "QobiScheme_*.ppm [~a~s-~a~s]~%"
	   (cond ((< (+ first-frame 1) 10) "0000")
		 ((< (+ first-frame 1) 100) "000")
		 ((< (+ first-frame 1) 1000) "00")
		 ((< (+ first-frame 1) 10000) "0")
		 (else ""))
	   (+ first-frame 1)
	   (cond ((< (+ last-frame 1) 10) "0000")
		 ((< (+ last-frame 1) 100) "000")
		 ((< (+ last-frame 1) 1000) "00")
		 ((< (+ last-frame 1) 10000) "0")
		 (else ""))
	   (+ last-frame 1))
   (format port "END_INPUT~%")
   (format port "PIXEL            HALF~%")
   (format port "RANGE            10~%")
   (format port "PSEARCH_ALG      LOGARITHMIC~%")
   (format port "BSEARCH_ALG      CROSS2~%")
   (format port "IQSCALE          8~%")
   (format port "PQSCALE          10~%")
   (format port "BQSCALE          25~%")
   (format port "REFERENCE_FRAME  ORIGINAL~%")
   (format port "BIT_RATE         1000000~%")
   (format port "BUFFER_SIZE      327680~%")
   (format port "FRAME_RATE       30~%")
   (format port "FORCE_ENCODE_LAST_FRAME~%")))
 (system (format #f "mpeg_encode ~a >/dev/null" (tmp "QobiScheme.param")))
 (system (format #f "rm -f ~a ~a"
		 (tmp "QobiScheme.{mpg,param}")
		 (tmp "QobiScheme_?????.ppm"))))

(define (ppm-hue ppm)
 (unless (ppm? ppm) (error "Argument to PPM-HUE is not a PPM"))
 (make-pgm (ppm-raw? ppm)
	   *max-hue*
	   (map-vector
	    (lambda (red-row green-row blue-row)
	     (map-vector
	      (lambda (red green blue)
	       (vector-ref (rgb->hsv (vector red green blue)) 0))
	      red-row
	      green-row
	      blue-row))
	    (ppm-red ppm)
	    (ppm-green ppm)
	    (ppm-blue ppm))))

(define (ppm-saturation ppm)
 (unless (ppm? ppm) (error "Argument to PPM-SATURATION is not a PPM"))
 (make-pgm (ppm-raw? ppm)
	   *max-saturation*
	   (map-vector
	    (lambda (red-row green-row blue-row)
	     (map-vector
	      (lambda (red green blue)
	       (vector-ref (rgb->hsv (vector red green blue)) 1))
	      red-row
	      green-row
	      blue-row))
	    (ppm-red ppm)
	    (ppm-green ppm)
	    (ppm-blue ppm))))

(define (ppm-value ppm)
 (unless (ppm? ppm) (error "Argument to PPM-VALUE is not a PPM"))
 (make-pgm (ppm-raw? ppm)
	   *max-value*
	   (map-vector
	    (lambda (red-row green-row blue-row)
	     (map-vector
	      (lambda (red green blue)
	       (vector-ref (rgb->hsv (vector red green blue)) 2))
	      red-row
	      green-row
	      blue-row))
	    (ppm-red ppm)
	    (ppm-green ppm)
	    (ppm-blue ppm))))

(define (pbm-and pbm1 pbm2)
 (unless (and (pbm? pbm1)
            (pbm? pbm2)
            (eq? (pbm-raw? pbm1) (pbm-raw? pbm2))
            (= (pnm-width pbm1) (pnm-width pbm2))
            (= (pnm-height pbm1) (pnm-height pbm2)))
  (error "Arguments to PBM-AND are not matching PBMs"))
 (make-pbm (pbm-raw? pbm1)
	   (map-vector
	    (lambda (row1 row2)
	     (map-vector (lambda (bit1 bit2) (and bit1 bit2)) row1 row2))
	    (pbm-bitmap pbm1)
	    (pbm-bitmap pbm2))))

(define (pbm-or pbm1 pbm2)
 (unless (and (pbm? pbm1)
            (pbm? pbm2)
            (eq? (pbm-raw? pbm1) (pbm-raw? pbm2))
            (= (pnm-width pbm1) (pnm-width pbm2))
            (= (pnm-height pbm1) (pnm-height pbm2)))
  (error "Arguments to PBM-OR are not matching PBMs"))
 (make-pbm (pbm-raw? pbm1)
	   (map-vector
	    (lambda (row1 row2)
	     (map-vector (lambda (bit1 bit2) (or bit1 bit2)) row1 row2))
	    (pbm-bitmap pbm1)
	    (pbm-bitmap pbm2))))

(define (pbm-not pbm)
 (unless (pbm? pbm) (error "Argument to PBM-NOT is not a PBM"))
 (make-pbm
  (pbm-raw? pbm)
  (map-vector (lambda (row) (map-vector not row)) (pbm-bitmap pbm))))

(define (pbm-xor pbm1 pbm2)
 (unless (and (pbm? pbm1)
            (pbm? pbm2)
            (eq? (pbm-raw? pbm1) (pbm-raw? pbm2))
            (= (pnm-width pbm1) (pnm-width pbm2))
            (= (pnm-height pbm1) (pnm-height pbm2)))
  (error "Arguments to PBM-XOR are not matching PBMs"))
 (make-pbm (pbm-raw? pbm1)
	   (map-vector
	    (lambda (row1 row2)
	     (map-vector (lambda (bit1 bit2) (xor bit1 bit2)) row1 row2))
	    (pbm-bitmap pbm1)
	    (pbm-bitmap pbm2))))

(define (pgm-absolute-difference pgm1 pgm2)
 (unless (and (pgm? pgm1)
            (pgm? pgm2)
            (= (pgm-maxval pgm1) (pgm-maxval pgm2))
            (eq? (pgm-raw? pgm1) (pgm-raw? pgm2))
            (= (pnm-width pgm1) (pnm-width pgm2))
            (= (pnm-height pgm1) (pnm-height pgm2)))
  (error "Arguments to PGM-ABSOLUTE-DIFFERENCE are not matching PGMs"))
 (make-pgm (pgm-raw? pgm1)
	   (pgm-maxval pgm1)
	   (map-vector
	    (lambda (row1 row2)
	     (map-vector (lambda (e1 e2) (abs (- e1 e2))) row1 row2))
	    (pgm-grey pgm1)
	    (pgm-grey pgm2))))

(define (empty-pnm? pnm)
 (cond
  ((ppm? pnm)
   (and (every-vector (lambda (row) (every-vector zero? row)) (ppm-red pnm))
      (every-vector (lambda (row) (every-vector zero? row)) (ppm-green pnm))
      (every-vector (lambda (row) (every-vector zero? row)) (ppm-blue pnm))))
  ((pgm? pnm)
   (every-vector (lambda (row) (every-vector zero? row)) (pgm-grey pnm)))
  ((pbm? pnm)
   (not
    (some-vector (lambda (row) (some-vector (lambda (a) a) row)) (pbm-bitmap pnm))))
  (else (error "Argument to EMPTY-PNM? is not a PNM"))))

(define (pbm-ascii pbm) (make-pbm #f (pbm-bitmap pbm)))

(define (pbm->pgm pbm)
 (unless (pbm? pbm) (error "Argument to PBM->PGM is not a PBM"))
 (make-pgm
  (pbm-raw? pbm)
  *max-grey*
  (map-vector
   (lambda (row) (map-vector (lambda (bit) (if bit *max-grey* 0)) row))
   (pbm-bitmap pbm))))

(define (pgm->ppm pgm)
 (unless (pgm? pgm) (error "Argument to PGM->PPM is not a PGM"))
 (make-ppm (pgm-raw? pgm)
	   (pgm-maxval pgm)
	   (pgm-grey pgm)
	   (pgm-grey pgm)
	   (pgm-grey pgm)))

(define (pbm->ppm pbm) (pgm->ppm (pbm->pgm pbm)))

(define (ppm->pgm ppm)
 (unless (ppm? ppm) (error "Argument to PPM->PGM is not a PPM"))
 (make-pgm
  (ppm-raw? ppm)
  (ppm-maxval ppm)
  (map-vector
   (lambda (red-row green-row blue-row)
    (map-vector (lambda (red green blue)
		 (inexact->exact
		  (floor (+ (* 0.299 red) (* 0.587 green) (* 0.114 blue)))))
		red-row green-row blue-row))
   (ppm-red ppm) (ppm-green ppm) (ppm-blue ppm))))

(define (pgm->pbm pgm threshold)
 (unless (pgm? pgm) (error "Argument to PGM->PBM is not a PGM"))
 (make-pbm (pgm-raw? pgm)
	   (map-vector
	    (lambda (row) (map-vector (lambda (grey) (>= grey threshold)) row))
	    (pgm-grey pgm))))

(define (ppm->pbm ppm threshold) (pgm->pbm (ppm->pgm ppm) threshold))

(define (pbm-constant width height bit)
 (make-pbm #t (make-matrix height width bit)))

(define (pgm-constant width height grey)
 (make-pgm #t *max-grey* (make-matrix height width grey)))

(define (ppm-constant width height red green blue)
 (make-ppm #t
	   (max *max-red* *max-green* *max-blue*)
	   (make-matrix height width red)
	   (make-matrix height width green)
	   (make-matrix height width blue)))

(define (pbm-left-vertical-stripe width height left)
 ;; Creates a black (#F) stripe on a white (#T) background.
 (let ((m (make-matrix height width #t)))
  (do ((y 0 (+ y 1))) ((= y height))
   (do ((x 0 (+ x 1))) ((= x left))
    (matrix-set! m y x #f)))
  (make-pbm #t m)))

(define (overlay-pbm-on-pnm pbm pnm)
 ;; The white (#T) pixels in the pbm become white in the result.
 (unless (and (pbm? pbm)
            (or (pbm? pnm) (pgm? pnm) (ppm? pnm))
            (eq? (pbm-raw? pbm) (pbm-raw? pnm))
            (= (pnm-width pbm) (pnm-width pnm))
            (= (pnm-height pbm) (pnm-height pnm)))
  (error "Arguments to OVERLAY-PBM-ON-PNM are not a matching PBM and PNM"))
 (cond
  ((ppm? pnm)
   (make-ppm (pbm-raw? pbm)
	     (max *max-red* *max-green* *max-blue*)
	     (map-vector (lambda (bitmap-row red-row)
			  (map-vector (lambda (bit red)
				       (if bit *max-red* red))
				      bitmap-row
				      red-row))
			 (pbm-bitmap pbm)
			 (ppm-red pnm))
	     (map-vector (lambda (bitmap-row green-row)
			  (map-vector (lambda (bit green)
				       (if bit *max-green* green))
				      bitmap-row
				      green-row))
			 (pbm-bitmap pbm)
			 (ppm-green pnm))
	     (map-vector (lambda (bitmap-row blue-row)
			  (map-vector (lambda (bit blue)
				       (if bit *max-blue* blue))
				      bitmap-row
				      blue-row))
			 (pbm-bitmap pbm)
			 (ppm-blue pnm))))
  ((pgm? pnm)
   (make-pgm (pbm-raw? pbm)
	     *max-grey*
	     (map-vector (lambda (bitmap-row grey-row)
			  (map-vector (lambda (bit grey)
				       (if bit *max-grey* grey))
				      bitmap-row
				      grey-row))
			 (pbm-bitmap pbm)
			 (pgm-grey pnm))))
  ((pbm? pnm) (pbm-or pbm pnm))
  (else (fuck-up))))

(define (pgm-smooth pgm sigma)
 (unless (pgm? pgm) (error "Argument to PGM-SMOOTH is not a PGM"))
 (let* ((height (pnm-height pgm))
	(width (pnm-width pgm))
	(grey1 (pgm-grey pgm))
	(grey2 (make-matrix height width 0)))
  (do ((y sigma (+ y 1))) ((= y (- height sigma)))
   (do ((x sigma (+ x 1))) ((= x (- width sigma)))
    (do ((i (- y sigma) (+ i 1))) ((= i (+ y sigma 1)))
     (do ((j (- x sigma) (+ j 1))) ((= j (+ x sigma 1)))
      (matrix-set!
       grey2 y x (+ (matrix-ref grey2 y x) (matrix-ref grey1 i j)))))
    (matrix-set!
     grey2 y x
     (inexact->exact
      (floor (/ (matrix-ref grey2 y x) (sqr (+ sigma sigma 1))))))))
  (make-pgm (pgm-raw? pgm) *max-grey* grey2)))

(define (normal-flow-magnitude pgm1 pgm2 epsilon sigma sensitivity)
 (unless (and (pgm? pgm1)
            (pgm? pgm2)
            (= (pgm-maxval pgm1) (pgm-maxval pgm2))
            (eq? (pgm-raw? pgm1) (pgm-raw? pgm2))
            (= (pnm-width pgm1) (pnm-width pgm2))
            (= (pnm-height pgm1) (pnm-height pgm2)))
  (error "Arguments to NORMAL-FLOW-MAGNITUDE are not matching PGMs"))
 (let* ((width (pnm-width pgm1))
	(height (pnm-height pgm1))
	(e1 (pgm-grey (pgm-smooth pgm1 sigma)))
	(e2 (pgm-grey (pgm-smooth pgm2 sigma)))
	(m (make-matrix height width 0)))
  (do ((i 0 (+ i 1))) ((= i (- height 1)))
   (do ((j 0 (+ j 1))) ((= j (- width 1)))
    (let* ((ex (/ (- (+ (matrix-ref e1 (+ i 1) j)
			(matrix-ref e1 (+ i 1) (+ j 1))
			(matrix-ref e2 (+ i 1) j)
			(matrix-ref e2 (+ i 1) (+ j 1)))
		     (+ (matrix-ref e1 i j)
			(matrix-ref e1 i (+ j 1))
			(matrix-ref e2 i j)
			(matrix-ref e2 i (+ j 1))))
		  4.0))
	   (ey (/ (- (+ (matrix-ref e1 i (+ j 1))
			(matrix-ref e1 (+ i 1) (+ j 1))
			(matrix-ref e2 i (+ j 1))
			(matrix-ref e2 (+ i 1) (+ j 1)))
		     (+ (matrix-ref e1 i j)
			(matrix-ref e1 (+ i 1) j)
			(matrix-ref e2 i j)
			(matrix-ref e2 (+ i 1) j)))
		  4.0))
	   (et (/ (- (+ (matrix-ref e2 i j)
			(matrix-ref e2 i (+ j 1))
			(matrix-ref e2 (+ i 1) j)
			(matrix-ref e2 (+ i 1) (+ j 1)))
		     (+ (matrix-ref e1 i j)
			(matrix-ref e1 i (+ j 1))
			(matrix-ref e1 (+ i 1) j)
			(matrix-ref e1 (+ i 1) (+ j 1))))
		  4.0))
	   (l (sqrt (+ (sqr ex) (sqr ey)))))
     (matrix-set!
      m i j
      (min *max-grey*
	   (inexact->exact
	    (floor
	     (* *max-grey*
		(/ (if (< l epsilon) 0.0 (/ (abs et) l)) sensitivity)))))))))
  (pgm-smooth (make-pgm (pgm-raw? pgm1) *max-grey* m) sigma)))

(define (threshold-normal-flow-magnitude pgm1 pgm2 epsilon sigma threshold)
 ;; The moving pixels become white (#T) in the result.
 (unless (and (pgm? pgm1)
            (pgm? pgm2)
            (= (pgm-maxval pgm1) (pgm-maxval pgm2))
            (eq? (pgm-raw? pgm1) (pgm-raw? pgm2))
            (= (pnm-width pgm1) (pnm-width pgm2))
            (= (pnm-height pgm1) (pnm-height pgm2)))
  (error "Arguments to THRESHOLD-NORMAL-FLOW-MAGNITUDE are not matching PGMs"))
 (let* ((width (pnm-width pgm1))
	(height (pnm-height pgm1))
	(e1 (pgm-grey (pgm-smooth pgm1 sigma)))
	(e2 (pgm-grey (pgm-smooth pgm2 sigma)))
	(m (make-matrix height width #f)))
  (do ((i 0 (+ i 1))) ((= i (- height 1)))
   (do ((j 0 (+ j 1))) ((= j (- width 1)))
    (let* ((ex (/ (- (+ (matrix-ref e1 (+ i 1) j)
			(matrix-ref e1 (+ i 1) (+ j 1))
			(matrix-ref e2 (+ i 1) j)
			(matrix-ref e2 (+ i 1) (+ j 1)))
		     (+ (matrix-ref e1 i j)
			(matrix-ref e1 i (+ j 1))
			(matrix-ref e2 i j)
			(matrix-ref e2 i (+ j 1))))
		  4.0))
	   (ey (/ (- (+ (matrix-ref e1 i (+ j 1))
			(matrix-ref e1 (+ i 1) (+ j 1))
			(matrix-ref e2 i (+ j 1))
			(matrix-ref e2 (+ i 1) (+ j 1)))
		     (+ (matrix-ref e1 i j)
			(matrix-ref e1 (+ i 1) j)
			(matrix-ref e2 i j)
			(matrix-ref e2 (+ i 1) j)))
		  4.0))
	   (et (/ (- (+ (matrix-ref e2 i j)
			(matrix-ref e2 i (+ j 1))
			(matrix-ref e2 (+ i 1) j)
			(matrix-ref e2 (+ i 1) (+ j 1)))
		     (+ (matrix-ref e1 i j)
			(matrix-ref e1 i (+ j 1))
			(matrix-ref e1 (+ i 1) j)
			(matrix-ref e1 (+ i 1) (+ j 1))))
		  4.0))
	   (l (sqrt (+ (sqr ex) (sqr ey)))))
     (matrix-set!
      m i j (and (>= l epsilon) (>= (/ (abs et) l) threshold))))))
  (make-pbm (pgm-raw? pgm1) m)))

(define (pbm-proximity-clusterer pbm threshold)
 ;; Clusters white (#T) pixels.
 (unless (pbm? pbm) (fuck-up))
 (let* ((width (pnm-width pbm))
	(height (pnm-height pbm))
	(m (map-vector (lambda (row) (map-vector (lambda (a) a) row))
		       (pbm-bitmap pbm)))
	(i -1)
	(threshold-squared (sqr threshold)))
  (do ((y 0 (+ y 1))) ((= y height))
   (do ((x 0 (+ x 1))) ((= x width))
    (when (eq? (matrix-ref m y x) #t)
     (matrix-set! m y x i)
     (let loop ()
      (let ((again? #f))
       (do ((y1 0 (+ y1 1))) ((= y1 height))
	(do ((x1 0 (+ x1 1))) ((= x1 width))
	 (when (eqv? (matrix-ref m y1 x1) i)
	  (do ((y2 (max 0 (- y1 threshold)) (+ y2 1)))
	    ((= y2 (min height (+ y1 threshold 1))))
	   (do ((x2 (max 0 (- x1 threshold)) (+ x2 1)))
	     ((= x2 (min width (+ x1 threshold 1))))
	    (when (and (<= (+ (sqr (- x1 x2)) (sqr (- y1 y2)))
                        threshold-squared)
                     (eq? (matrix-ref m y2 x2) #t))
	     (matrix-set! m y2 x2 i)
	     (set! again? #t)))))))
       (when again? (loop))))
     (set! i (- i 1)))))
  (let ((clusters (make-vector (- (- i) 1) '())))
   (do ((y 0 (+ y 1))) ((= y height))
    (do ((x 0 (+ x 1))) ((= x width))
     (let ((i (matrix-ref m y x)))
      (when i
       (vector-set! clusters
		    (- (- i) 1)
		    (cons (vector x y) (vector-ref clusters (- (- i) 1))))))))
   (vector->list clusters))))

(define (pbm-bloat pbm n)
 ;; Bloats white (#T) pixels.
 (let* ((height (pnm-height pbm))
	(width (pnm-width pbm))
	(bitmap (pbm-bitmap pbm))
	(new (make-matrix height width #f)))
  (do ((y 0 (+ y 1))) ((>= y height))
   (do ((x 0 (+ x 1))) ((>= x width))
    (do ((y0 (- y n) (+ y0 1))) ((> y0 (+ y n)))
     (when (and (>= y0 0) (< y0 height))
      (do ((x0 (- x n) (+ x0 1))) ((> x0 (+ x n)))
       (when (and (>= x0 0) (< x0 width) (matrix-ref bitmap y0 x0))
	(matrix-set! new y x #t)))))))
  (make-pbm (pbm-raw? pbm) new)))

(define (pnm-shift pnm delta)
 (cond
  ((ppm? pnm)
   (let* ((height (pnm-height pnm))
	  (width (pnm-width pnm))
	  (red (ppm-red pnm))
	  (green (ppm-green pnm))
	  (blue (ppm-blue pnm))
	  (new-red (make-matrix height width 0))
	  (new-green (make-matrix height width 0))
	  (new-blue (make-matrix height width 0))
	  (dy (y delta))
	  (dx (x delta)))
    (do ((y 0 (+ y 1))) ((>= y height))
     (when (and (>= (- y dy) 0) (< (- y dy) height))
      (do ((x 0 (+ x 1))) ((>= x width))
       (when (and (>= (- x dx) 0) (< (- x dx) width))
	(matrix-set! new-red y x (matrix-ref red (- y dy) (- x dx)))
	(matrix-set! new-green y x (matrix-ref green (- y dy) (- x dx)))
	(matrix-set! new-blue y x (matrix-ref blue (- y dy) (- x dx)))))))
    (make-ppm (ppm-raw? pnm) (ppm-maxval pnm) new-red new-green new-blue)))
  ((pgm? pnm)
   (let* ((height (pnm-height pnm))
	  (width (pnm-width pnm))
	  (grey (pgm-grey pnm))
	  (new-grey (make-matrix height width 0))
	  (dy (y delta))
	  (dx (x delta)))
    (do ((y 0 (+ y 1))) ((>= y height))
     (when (and (>= (- y dy) 0) (< (- y dy) height))
      (do ((x 0 (+ x 1))) ((>= x width))
       (when (and (>= (- x dx) 0) (< (- x dx) width))
	(matrix-set! new-grey y x (matrix-ref grey (- y dy) (- x dx)))))))
    (make-pgm (pgm-raw? pnm) (pgm-maxval pnm) new-grey)))
  ((pbm? pnm)
   (let* ((height (pnm-height pnm))
	  (width (pnm-width pnm))
	  (bitmap (pbm-bitmap pnm))
	  (new-bitmap (make-matrix height width #f))
	  (dy (y delta))
	  (dx (x delta)))
    (do ((y 0 (+ y 1))) ((>= y height))
     (when (and (>= (- y dy) 0) (< (- y dy) height))
      (do ((x 0 (+ x 1))) ((>= x width))
       (when (and (>= (- x dx) 0) (< (- x dx) width))
	(matrix-set! new-bitmap y x (matrix-ref bitmap (- y dy) (- x dx)))))))
    (make-pbm (pbm-raw? pnm) new-bitmap)))
  (else (error "Argument is not a PNM"))))

(define (pnm-copy pnm)
 (cond
  ((ppm? pnm)
   (make-ppm (ppm-raw? pnm)
	     (ppm-maxval pnm)
	     (matrix-copy (ppm-red pnm))
	     (matrix-copy (ppm-green pnm))
	     (matrix-copy (ppm-blue pnm))))
  ((pgm? pnm)
   (make-pgm (pgm-raw? pnm) (pgm-maxval pnm) (matrix-copy (pgm-grey pnm))))
  ((pbm? pnm) (make-pbm (pbm-raw? pnm) (matrix-copy (pbm-bitmap pnm))))
  (else (error "Argument is not a PNM"))))

(define (pnm-black-window pnm upper-left lower-right)
 (cond ((ppm? pnm)
	(let* ((ppm (pnm-copy pnm))
	       (red (ppm-red ppm))
	       (green (ppm-green ppm))
	       (blue (ppm-blue ppm))
	       (yl (y upper-left))
	       (yh (y lower-right))
	       (xl (x upper-left))
	       (xh (x lower-right))
	       (height (pnm-height ppm))
	       (width (pnm-width ppm)))
	 (do ((y 0 (+ y 1))) ((>= y height))
	  (do ((x 0 (+ x 1))) ((>= x width))
	   (unless (and (>= y yl) (< y yh) (>= x xl) (< x xh))
	    (matrix-set! red y x 0)
	    (matrix-set! green y x 0)
	    (matrix-set! blue y x 0))))
	 ppm))
       ((pgm? pnm)
	(let* ((pgm (pnm-copy pnm))
	       (grey (pgm-grey pgm))
	       (yl (y upper-left))
	       (yh (y lower-right))
	       (xl (x upper-left))
	       (xh (x lower-right))
	       (height (pnm-height pgm))
	       (width (pnm-width pgm)))
	 (do ((y 0 (+ y 1))) ((>= y height))
	  (do ((x 0 (+ x 1))) ((>= x width))
	   (unless (and (>= y yl) (< y yh) (>= x xl) (< x xh))
	    (matrix-set! grey y x 0))))
	 pgm))
       ((pbm? pnm)
	(let* ((pbm (pnm-copy pnm))
	       (bitmap (pbm-bitmap pbm))
	       (yl (y upper-left))
	       (yh (y lower-right))
	       (xl (x upper-left))
	       (xh (x lower-right))
	       (height (pnm-height pbm))
	       (width (pnm-width pbm)))
	 (do ((y 0 (+ y 1))) ((>= y height))
	  (do ((x 0 (+ x 1))) ((>= x width))
	   (unless (and (>= y yl) (< y yh) (>= x xl) (< x xh))
	    (matrix-set! bitmap y x #f))))
	 pbm))
       (else (error "Argument is not a PNM"))))

(define (pnm-white-window pnm upper-left lower-right)
 (cond ((ppm? pnm)
	(let* ((ppm (pnm-copy pnm))
	       (maxval (ppm-maxval ppm))
	       (red (ppm-red ppm))
	       (green (ppm-green ppm))
	       (blue (ppm-blue ppm))
	       (yl (y upper-left))
	       (yh (y lower-right))
	       (xl (x upper-left))
	       (xh (x lower-right))
	       (height (pnm-height ppm))
	       (width (pnm-width ppm)))
	 (do ((y 0 (+ y 1))) ((>= y height))
	  (do ((x 0 (+ x 1))) ((>= x width))
	   (unless (and (>= y yl) (< y yh) (>= x xl) (< x xh))
	    (matrix-set! red y x maxval)
	    (matrix-set! green y x maxval)
	    (matrix-set! blue y x maxval))))
	 ppm))
       ((pgm? pnm)
	(let* ((pgm (pnm-copy pnm))
	       (maxval (pgm-maxval pgm))
	       (grey (pgm-grey pgm))
	       (yl (y upper-left))
	       (yh (y lower-right))
	       (xl (x upper-left))
	       (xh (x lower-right))
	       (height (pnm-height pgm))
	       (width (pnm-width pgm)))
	 (do ((y 0 (+ y 1))) ((>= y height))
	  (do ((x 0 (+ x 1))) ((>= x width))
	   (unless (and (>= y yl) (< y yh) (>= x xl) (< x xh))
	    (matrix-set! grey y x maxval))))
	 pgm))
       ((pbm? pnm)
	(let* ((pbm (pnm-copy pnm))
	       (bitmap (pbm-bitmap pbm))
	       (yl (y upper-left))
	       (yh (y lower-right))
	       (xl (x upper-left))
	       (xh (x lower-right))
	       (height (pnm-height pbm))
	       (width (pnm-width pbm)))
	 (do ((y 0 (+ y 1))) ((>= y height))
	  (do ((x 0 (+ x 1))) ((>= x width))
	   (unless (and (>= y yl) (< y yh) (>= x xl) (< x xh))
	    (matrix-set! bitmap y x #t))))
	 pbm))
       (else (error "Argument is not a PNM"))))

(define (points->pbm-of-size points height width)
 ;; Takes a list of what will be the white (#T) points in the pbm image.
 (let ((bitmap (make-matrix height width #f)))
  (for-each (lambda (point) (matrix-set! bitmap (y point) (x point) #t))
   points)
  (make-pbm #t bitmap)))

(define (pbm-ppm-and pbm ppm)
 ;; White (#T) pixels in the PBM are kept from the PPM. Black (#F) pixels in
 ;; the PBM become white in the result.
 (unless (and (pbm? pbm)
            (ppm? ppm)
            (= (pnm-width pbm) (pnm-width ppm))
            (= (pnm-height pbm) (pnm-height ppm)))
  (error "Arguments to PBM-PPM-AND are not matching PBMs"))
 (make-ppm (ppm-raw? ppm)
	   (ppm-maxval ppm)
	   (map-vector
	    (lambda (row red)
	     (map-vector (lambda (bit red) (if bit red *max-red*))
			 row red))
	    (pbm-bitmap pbm)
	    (ppm-red ppm))
	   (map-vector
	    (lambda (row green)
	     (map-vector (lambda (bit green) (if bit green *max-green*))
			 row green))
	    (pbm-bitmap pbm)
	    (ppm-green ppm))
	   (map-vector
	    (lambda (row blue)
	     (map-vector (lambda (bit blue) (if bit blue *max-blue*))
			 row blue))
	    (pbm-bitmap pbm)
	    (ppm-blue ppm))))

(define (pnm-rotate pnm)
 (cond ((pbm? pnm)
	(make-pbm (pbm-raw? pnm) (matrix-transpose (pbm-bitmap pnm))))
       ((pgm? pnm)
	(make-pgm (pgm-raw? pnm)
		  (pgm-maxval pnm)
		  (matrix-transpose (pgm-grey pnm))))
       ((ppm? pnm)
	(make-ppm (ppm-raw? pnm)
		  (ppm-maxval pnm)
		  (matrix-transpose (ppm-red pnm))
		  (matrix-transpose (ppm-green pnm))
		  (matrix-transpose (ppm-blue pnm))))
       (else (error "Argument is not a PNM"))))

(define (pnm-flip pnm)
 (cond ((pbm? pnm)
	(make-pbm (pbm-raw? pnm)
		  (list->vector (reverse (vector->list (pbm-bitmap pnm))))))
       ((pgm? pnm)
	(make-pgm (pgm-raw? pnm)
		  (pgm-maxval pnm)
		  (list->vector (reverse (vector->list (pgm-grey pnm))))))
       ((ppm? pnm)
	(make-ppm (ppm-raw? pnm)
		  (ppm-maxval pnm)
		  (list->vector (reverse (vector->list (ppm-red pnm))))
		  (list->vector (reverse (vector->list (ppm-green pnm))))
		  (list->vector (reverse (vector->list (ppm-blue pnm))))))
       (else (error "Argument is not a PNM"))))

(define (flatten-ppm ppm colour-transform)
 (map-vector
  (lambda (red-row green-row blue-row)
   (map-vector
    (lambda (r g b)
     (colour-transform `#(,r ,g ,b)))
    red-row green-row blue-row))
  (ppm-red ppm) (ppm-green ppm) (ppm-blue ppm)))

(define (ppm-mean image colour-transform)
 (let ((acc (colour-transform '#(0 0 0))))
  (for-each-vector
   (lambda (red-row green-row blue-row)
    (for-each-vector
     (lambda (r g b)
      (set! acc (v+ acc (colour-transform `#(,r ,g ,b)))))
     red-row green-row blue-row))
   (ppm-red image) (ppm-green image) (ppm-blue image))
  (k*v (/ 1 (* (pnm-height image) (pnm-width image))) acc)))

(define (ppm-covariance image colour-transform)
 (let* ((mu (ppm-mean image colour-transform))
	(acc (make-matrix (vector-length mu) (vector-length mu) 0)))
  (for-each-vector
   (lambda (red-row green-row blue-row)
    (for-each-vector
     (lambda (r g b)
      (set!
       acc
       (m+ acc (self-outer-product * (v- (colour-transform `#(,r ,g ,b)) mu)))))
     red-row green-row blue-row))
   (ppm-red image) (ppm-green image) (ppm-blue image))
  (k*m (/ 1 (* (pnm-height image) (pnm-width image))) acc)))

(define (pgm-and-pbm pgm pbm)
 (map-vector (lambda (eg eb) (map-vector (lambda (eg eb) (if eb eg 0)) eg eb))
	     (pgm-grey pgm) (pbm-bitmap pbm)))

(define (pbm-skeletonize pbm)
 (let ((height (pnm-height pbm)) (width (pnm-width pbm)))
  (let loop ((bitmap (pbm-bitmap pbm)))
   (let ((new-bitmap (map-vector (lambda (row) (map-vector (lambda (a) a) row)) bitmap)))
    (for-each-n
     (lambda (y)
      (for-each-n
       (lambda (x)
	(when (and
	       (matrix-ref bitmap y x)
	       (<= 4
		   (+ (if (and (not (zero? y))
			       (not (zero? x))
			       (matrix-ref bitmap (- y 1) (- x 1)))
			  1
			  0)
		      (if (and (not (zero? y))
			       (matrix-ref bitmap (- y 1) x))
			  1
			  0)
		      (if (and (not (zero? y))
			       (not (= x (- width 1)))
			       (matrix-ref bitmap (- y 1) (+ x 1)))
			  1
			  0)
		      (if (and (not (zero? x))
			       (matrix-ref bitmap y (- x 1)))
			  1
			  0)
		      (if (and (not (= x (- width 1)))
			       (matrix-ref bitmap y (+ x 1)))
			  1
			  0)
		      (if (and (not (= y (- height 1)))
			       (not (zero? x))
			       (matrix-ref bitmap (+ y 1) (- x 1)))
			  1
			  0)
		      (if (and (not (= y (- height 1)))
			       (matrix-ref bitmap (+ y 1) x))
			  1
			  0)
		      (if (and (not (= y (- height 1)))
			       (not (= x (- width 1)))
			       (matrix-ref bitmap (+ y 1) (+ x 1)))
			  1
			  0))
		   7))
	 (matrix-set! new-bitmap y x #f)))
       width))
     height)
    (if (equal? new-bitmap bitmap)
	(make-pbm (pbm-raw? pbm) bitmap)
	(loop new-bitmap))))))

(define (pbm-flood pbm point)
 (let ((new-bitmap
	(map-vector (lambda (row) (map-vector (lambda (a) a) row)) (pbm-bitmap pbm)))
       (height (pnm-height pbm))
       (width (pnm-width pbm)))
  (let loop ((point point))
   (when (and (<= 0 (y point) (- height 1)) (<= 0 (x point) (- width 1)))
    (unless (matrix-ref new-bitmap (y point) (x point))
     (matrix-set! new-bitmap (y point) (x point) #t)
     (loop (vector (- (x point) 1) (y point)))
     (loop (vector (+ (x point) 1) (y point)))
     (loop (vector (x point) (- (y point) 1)))
     (loop (vector (x point) (+ (y point) 1))))))
  (make-pbm (pbm-raw? pbm) new-bitmap)))

(define (find-histogram pixmap maxval)
 (let ((bin (make-vector (+ maxval 1) 0)))
  (for-each-vector
   (lambda (row)
    (for-each-vector
     (lambda (col)
      (vector-set! bin col (+ (vector-ref bin col) 1)))
     row))
   pixmap)
  bin))

(define (histogram-mean histogram i)
 (let ((n (qreduce-vector + histogram 0)))
  (/ (qreduce-vector
      + (map-indexed-vector (lambda (n j) (* n (+ i j))) histogram) 0) n)))

(define (histogram-variance histogram mu i)
 (let ((n (qreduce-vector + histogram 0)))
  (/ (qreduce-vector
      + (map-indexed-vector (lambda (n j) (* (sqr (- (+ i j) mu)) n)) histogram) 0)
     n)))

(define (normalised-histogram histogram val)
 (map-vector (lambda (v) (/ v val)) histogram))

(define (weighted-histogram histogram)
 (map-indexed-vector (lambda (n i) (* n (+ i 1))) histogram))

(define (cumulative-histogram histogram)
 (let ((h (map-vector (lambda (v) v) histogram)))
  (let loop ((i 1))
   (when (< i (vector-length h))
    (vector-set! h i (+ (vector-ref h (- i 1)) (vector-ref h i)))
    (loop (+ i 1))))
  h))

(define (find-between-class-variances omegas mus mu-total)
 (map-vector
  (lambda (omega mu)
   (if (or (= omega 0) (= omega 1)) 0 (/ (sqr (- (* mu-total omega) mu)) (* omega (- 1 omega)))))
  omegas
  mus))

(define (binary-threshold pgm threshold)
 (unless (pgm? pgm) (panic "Argument is not a PGM"))
 (make-pbm #f (map-vector
	       (lambda (row)
		(map-vector
		 (lambda (col) (> col threshold)) row))
	       (pgm-grey pgm))))

;; Optimal Threshold - Otsu's Method
(define (find-threshold-otsu pgm)
 (let* ((normalised-histogram
	 (map-vector (lambda (v) (/ v (* (pnm-width pgm) (pnm-height pgm))))
		     (find-histogram (pgm-grey pgm) (pgm-maxval pgm))))
	(first-cumulative-moments
	 (cumulative-histogram
	  (map-indexed-vector (lambda (n i) (* n (+ i 1))) normalised-histogram)))
	(between-class-sigmas
	 (find-between-class-variances
	  (cumulative-histogram normalised-histogram)
	  first-cumulative-moments
	  (vector-ref first-cumulative-moments
		      (- (vector-length first-cumulative-moments) 1)))))
  (vector-positione (qreduce-vector max between-class-sigmas -inf.0)
                    between-class-sigmas)))

(define (binary-threshold-optimal pgm)
 (unless (pgm? pgm) (panic "Argument is not a PGM"))
 (binary-threshold pgm (find-threshold-otsu pgm)))

;;; Optimal Threshold - Method of Successive Means
(define (find-threshold-means pgm)
 (let* ((histogram (find-histogram (pgm-grey pgm) (pgm-maxval pgm)))
	(l (vector-length histogram)))
  (let loop ((t (/ l 2)) (oldt 0))
   (if (<= (abs (- t oldt)) 1)
       t
       (loop (inexact->exact
	      (round (/ (+ (histogram-mean (subvector histogram 0 t) 0)
			   (histogram-mean (subvector histogram t l) t))
			2)))
	     t)))))

(define (binary-threshold-means pgm)
 (unless (pgm? pgm) (panic "Argument is not a PGM"))
 (binary-threshold pgm (find-threshold-means pgm)))

;;; Colour Threshold
(define (sample-image ppm colour-tx window-centre window-size)
 (let* ((halfwin (inexact->exact (/ window-size 2)))
	(tlx (- (x window-centre) halfwin))
	(tly (- (y window-centre) halfwin)))
  (map-vector
   (lambda (r g b) (colour-tx `#(,r ,g ,b)))
   (unshape-matrix (crop (ppm-red ppm) tlx tly window-size window-size))
   (unshape-matrix (crop (ppm-green ppm) tlx tly window-size window-size))
   (unshape-matrix (crop (ppm-blue ppm) tlx tly window-size window-size)))))

(define (binary-threshold-colour ppm colour-tx point threshold)
 (let* ((window-size 21)
	(colour-values (sample-image ppm colour-tx point window-size))
	(mu (vectors-mean colour-values))
	(isigma (invert-matrix (vectors-variance mu colour-values))))
  (make-pbm #f
	    (map-vector
	     (lambda (red-row green-row blue-row)
	      (map-vector
	       (lambda (r g b)
		(< (mahalanobis-distance (colour-tx `#(,r ,g ,b)) mu isigma)
		   threshold))
	       red-row
	       green-row
	       blue-row))
	     (ppm-red ppm)
	     (ppm-green ppm)
	     (ppm-blue ppm)))))

;;; Histogram Equalization
(define (histogram-equalise pgm)
 (let* ((w (pnm-width pgm))
	(h (pnm-height pgm))
	(cdf (cumulative-histogram
	      (find-histogram (pgm-grey pgm) (pgm-maxval pgm))))
	(min-cdf (qreduce-vector min cdf +inf.0)))
  (make-pgm (pgm-raw? pgm)
	    (pgm-maxval pgm)
	    (map-vector
	     (lambda (row)
	      (map-vector
	       (lambda (val)
		(inexact->exact
		 (round (* (- (pgm-maxval pgm) 1)
			   (/ (- (vector-ref cdf val) min-cdf)
			      (- (* w h) 1))))))
	       row))
	     (pgm-grey pgm)))))

(define (colour-threshold ppm colour-tx mu isigma threshold)
 (make-pbm #f
	   (map-vector
	    (lambda (red-row green-row blue-row)
	     (map-vector
	      (lambda (r g b)
	       (< (mahalanobis-distance (colour-tx `#(,r ,g ,b)) mu isigma)
		  threshold))
	      red-row
	      green-row
	      blue-row))
	    (ppm-red ppm)
	    (ppm-green ppm)
	    (ppm-blue ppm))))

;;; Adaptive Thresholding
(define (make-integral-matrix matrix)
 (let ((integral-matrix
	(make-matrix (matrix-rows matrix) (matrix-columns matrix) 0)))
  (map-n
   (lambda (i)
    (map-n
     (lambda (j)
      (let ((current-val (matrix-ref matrix i j)))
       (matrix-set!
	integral-matrix i j
	(cond ((and (zero? i) (zero? j)) current-val)
	      ((zero? i) (+ current-val
			    (matrix-ref integral-matrix i (- j 1))))
	      ((zero? j) (+ current-val
			    (matrix-ref integral-matrix (- i 1) j)))
	      (else (+ current-val
		       (matrix-ref integral-matrix i (- j 1))
		       (matrix-ref integral-matrix (- i 1) j)
		       (- (matrix-ref integral-matrix (- i 1) (- j 1)))))))))
     (matrix-columns matrix)))
   (matrix-rows matrix))
  integral-matrix))

(define (compute-integral-matrix-mu integral-matrix x y w)
 (let ((r (- (matrix-rows integral-matrix) 1))
       (c (- (matrix-columns integral-matrix) 1))
       (del1 (inexact->exact (/ w 2)))
       (del2 (inexact->exact (ceiling (/ w 2)))))
  (/ (- (+ (matrix-ref integral-matrix (min (+ x del1) r) (min (+ y del1) c))
	   (matrix-ref integral-matrix (max (- x del2) 0) (max (- y del2) 0)))
	(+ (matrix-ref integral-matrix (min (+ x del1) r) (max (- y del2) 0))
	   (matrix-ref integral-matrix (max (- x del2) 0) (min (+ y del1) c))))
     (* w w))))

(define (compute-integral-matrix-sigma squared-integral-matrix mu x y w)
 (sqrt (- (compute-integral-matrix-mu squared-integral-matrix x y w)
	  (* mu mu))))

(define (compute-adaptive-threshold
	 integral-matrix squared-integral-matrix x y w)
 (let ((k 0.2) (R 128)
       (mu (compute-integral-matrix-mu integral-matrix x y w)))
  (* mu (+ 1 (* k (- (/ (compute-integral-matrix-sigma
			squared-integral-matrix mu x y w) R)
		    1))))))

(define (adaptive-threshold pgm winsize)
 (let* ((pixmap (pgm-grey pgm))
	(integral-pixmap (make-integral-matrix pixmap))
	(squared-integral-pixmap
	 (make-integral-matrix (map-matrix sqr pixmap))))
  (make-pbm (pgm-raw? pgm)
	    (map-n-vector
	     (lambda (i)
	      (map-n-vector
	       (lambda (j)
		(> (matrix-ref pixmap i j)
		   (compute-adaptive-threshold
		    integral-pixmap squared-integral-pixmap i j winsize)))
	       (matrix-columns pixmap)))
	     (matrix-rows pixmap)))))

(define (pgm-mean image)
 (histogram-mean (find-histogram (pgm-grey image) (pgm-maxval image)) 0))

(define (pgm-variance image)
 (let ((hist (find-histogram (pgm-grey image) (pgm-maxval image))))
  (histogram-variance hist (histogram-mean hist 0) 0)))
)
